# 비트연산자(bitwise operator)

- 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자
- 비트 단위로 왼쪽이나 오른쪽으로 전체 비트를 이동하거나, 1의 보수를 만들 때도 사용

| 비트연산자 | 설명 |
| :--------: | :--: |
|     &      | 대응되는 비트가 모두 1이면 1을 반환 (AND연산) |
| \| | 대응되는 비트 중에서 하나라도 1이면 1을 반환 (OR연산) |
| ^ | 대응되는 비트가 서로 다르면 1을 반환 (XOR 연산) |
| ~ | 비트를 반전 (NOT 연산, 1의 보수) |
| << | 명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴 (left shift연산) |
| \>> | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동 (right shift연산) |
| \>>> | 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨 |



#### 비트 AND 연산

- 대응되는 비트가 모두 1일때만 1을 반환
  - 00001111 & 00010101 = 00000101

#### 비트 OR 연산

- 하나라도 1이면 1을 반환
  - 00001111 | 00010101 = 00011111

#### 비트 XOR 연산

- 다르면 1, 같으면 0 반환
  - 00001111 ^ 00010101 = 00011010

#### 비트 NOT 연산

- 비트를 반전 시킴
  - ~00001111 = 11110000



```java
int num1 = 8, num2 = -8;
//num1 = 00001000, num2 = 11111000
System.out.println("~ 연산자에 의한 결과 : "+ ~num1); //1) -9
System.out.println("<< 연산자에 의한 결과 : "+ (num1 << 2)); 
//2) 2만큼 왼쪽으로 이동, 오른쪽에 생기는 빈칸은 0으로 채워준다, 한 칸 이동할 때마다 *2
// 00100000 = 32

System.out.println(">> 연산자에 의한 결과 : "+ (num2 >> 2)); 
//3) 2만큼 오른쪽으로 이동, 왼쪽에 생기는 빈 비트들은 양수일 경우 0, 음수일 경우 1로 채워준다
// 따라서 부호는 변화지 않는다. 한칸 이동할 때마다 /2
// 11111110 = -2

System.out.println(">>> 연산자에 의한 결과 : "+ (num1 >>> 2)); 
//4) 부호비트까지 포함하여 비트 이동, 양수일 경우 >>와 같은 결과 2
System.out.println(">>> 연산자에 의한 결과 : "+ (num2 >>> 2)); 
//5) 음수인 경우, 부호비트도 이동, 00111110 = 1073741822
```

